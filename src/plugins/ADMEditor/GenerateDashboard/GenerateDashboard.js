/**
 * Generated by PluginGenerator from webgme on Tue Nov 04 2014 13:59:08 GMT-0600 (Central Standard Time).
 */

define(['plugin/PluginConfig',
    'plugin/PluginBase',
    'jszip',
    'plugin/GenerateDashboard/GenerateDashboard/meta',
        'plugin/GenerateDashboard/GenerateDashboard/dashboardTypes',
        'plugin/AdmExporter/AdmExporter/AdmExporter',
        'xmljsonconverter'
    ], function (PluginConfig, PluginBase, JSZip, MetaTypes, DashboardTypes, AdmExporter, Converter) {
    'use strict';

    /**
    * Initializes a new instance of GenerateDashboard.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin GenerateDashboard.
    * @constructor
    */
    var GenerateDashboard = function () {
        // Call base class' constructor.
        PluginBase.call(this);

        this.metaTypes = MetaTypes;
        this.admExporter = null;
        this.designSpaceNode = null;
        this.json2xml = null;

        this.dashboardObject = {
            "dashboard": "dashboard blob hash",
            "indexHtml": "index.html blob hash",
            "designs": {},
            "designSpace": "design adm string",
            "requirements": "dummy requirements blob hash",
            "results": {
                "resultsMetaresultsJson": null,
                results: {}
            },
            "testBenches": {},
            "manifestProjectJson": null
        };
    };

    // Prototypal inheritance from PluginBase.
    GenerateDashboard.prototype = Object.create(PluginBase.prototype);
    GenerateDashboard.prototype.constructor = GenerateDashboard;

    /**
    * Gets the name of the GenerateDashboard.
    * @returns {string} The name of the plugin.
    * @public
    */
    GenerateDashboard.prototype.getName = function () {
        return "Generate Dashboard";
    };

    /**
    * Gets the semantic version (semver.org) of the GenerateDashboard.
    * @returns {string} The version of the plugin.
    * @public
    */
    GenerateDashboard.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Gets the description of the GenerateDashboard.
    * @returns {string} The description of the plugin.
    * @public
    */
    GenerateDashboard.prototype.getDescription = function () {
        return "Takes a list of Result Object IDs, and create a Dashboard package for visualization";
    };

    /**
     * Gets the configuration structure for the TestBenchRunner.
     * The ConfigurationStructure defines the configuration for the plugin
     * and will be used to populate the GUI when invoking the plugin from webGME.
     * @returns {object} The version of the plugin.
     * @public
     */
    GenerateDashboard.prototype.getConfigStructure = function () {
        return [
            {
                'name': 'ResultIDs',
                'displayName': 'Result Object IDs',
                'description': 'IDs of Result objects to add to the Generated Dashboard, separated by semicolons.',
                'value': '',
                'valueType': 'string',
                'readOnly': false
            }
        ];
    };

    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always has to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    GenerateDashboard.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            //config = self.getCurrentConfig(),
            workspaceName = self.core.getAttribute(self.rootNode, 'name'),// NOPE. this is 'ADMEditor', not 'rollo'
            designName = self.core.getAttribute(self.activeNode, 'name'),
            designObjectID = self.core.getPath(self.activeNode),
            designID = self.core.getGuid(self.activeNode),
            resultObjectIDs = [
                "/243203739/1914067160/1594627875/738670268/1604609344/1138983316",
                "/243203739/1914067160/1594627875/738670268/1604609344/638117119",
                "/243203739/1914067160/1594627875/738670268/14675327/721601556",
                "/243203739/1914067160/1594627875/738670268/14675327/669656366"
            ];

        self.updateMETA(self.metaTypes);
        self.json2xml = new Converter.Json2xml();
        self.designSpaceNode = self.activeNode;

        // Run AdmExporter to get design_space/%ThisDesignName%.adm
        self.initializeAdmExporter(designObjectID);

        // self.activeNode needs to be the design, 2nd argument is bool: include/return acm files
        var exploreDesignCallbackFunction = function (err) {
            if (err) {
                self.logger.error('AdmExporter.exploreDesign failed with error: ' + err);
                self.logger.error(err);
                self.result.setSuccess(false);
                return callback(err, self.result);
            }

            var admData = self.admExporter.admData;

            self.dashboardObject.designSpace = self.json2xml.convertToString({Design: self.admExporter.admData});

            // Create the manifest.project.json file
            self.dashboardObject.manifestProjectJson = new DashboardTypes.manifestProjectJson(workspaceName);

            // Create the results.metaresults.json file
            self.dashboardObject.results.resultsMetaresultsJson = new DashboardTypes.resultsMetaresultsJson();

            // Create requirements
            self.dashboardObject.requirements = JSON.stringify(new DashboardTypes.requirementsJson(), null, 4);

            var getResultsCallbackFunction = function (err) {
                if (err) {
                    self.logger.error(err);
                    self.result.setSuccess(false);
                    return callback(err, self.result);
                }

                // we should have here a full 'self.dashboardObject', ready for creating an artifact (???)
                self.createDashboardArtifact(function (err) {
                    self.result.setSuccess(true);
                    self.save('added obj', function (err) {
                        callback(null, self.result);
                    });
                });
            };

            self.getResults(designName, designID, resultObjectIDs, getResultsCallbackFunction);

        };
        
        self.admExporter.exploreDesign(self.designSpaceNode, false, exploreDesignCallbackFunction);
    };

    GenerateDashboard.prototype.createDashboardArtifact = function () {
        var self = this,
            filesToAdd = {},
            dashboardArtifact = self.blobClient.createArtifact('dashboard');


    };

    GenerateDashboard.prototype.getResults = function (designSpaceName, designSpaceID, resultObjectIDs, callback) {
        var self = this,
            resultCounter = 0,
            cumulativeError = "";

        var incrementCounterCallback = function (err) {
            if (err) {
                cumulativeError += err;
            }

            resultCounter += 1;

            if (resultCounter === resultObjectIDs.length) {
                return callback(cumulativeError);
            }
        };

        // Iterate over the list of Result IDs (async with counter)
        var loadByPathCallbackFunction = function (err, loadedNode) {
            if (err) {
                return incrementCounterCallback(err);
            }

            self.readAndModifyResultData(loadedNode, designSpaceName, designSpaceID, incrementCounterCallback);
        };

        for (var i=0;i<resultObjectIDs.length;i++) {

            self.core.loadByPath(self.rootNode, resultObjectIDs[i], loadByPathCallbackFunction);
        }
    };

    GenerateDashboard.prototype.readAndModifyResultData = function (resultNode, designSpaceName, designSpaceID, callback) {
        var self = this,
            tbManifestHash = self.core.getAttribute(resultNode, 'Artifacts'),
            cfgAdmHash = self.core.getAttribute(resultNode, 'CfgAdm'),
            configNode = self.core.getParent(resultNode),  // the parent config object
            configNodeName = self.core.getAttribute(configNode, 'name'),  // the webgme name for the config
            configName = configNodeName.replace(". ", "_").replace(": ", "_"),  // the 'safer' name
            configNodeGuid = self.core.getGuid(configNode);  // the DesignID for this result's config

        self.getTestbenchManifest(tbManifestHash, function (err, tbManifestJson) {
            if (err) {
                return callback(err);
            }

            self.processTestbenchManifest(tbManifestJson, designSpaceName, configName, configNodeGuid);

            // Check if there is already an adm for this config
            if (self.dashboardObject.designs.hasOwnProperty(configNodeGuid)) {
                callback(null);
            } else {
                self.getCfgAdm(cfgAdmHash, function (err, admJson) {
                    if (err) {
                        return callback(err);
                    }

                    // 'rename' it (designSpaceName), and set the ID (designSpaceID)
                    admJson.Design['@DesignID'] = configNodeGuid;
                    admJson.Design['@Name'] = configName;
                    admJson.Design['@DesignSpaceSrcID'] = '{' + designSpaceID + '}';

                    self.dashboardObject.designs[configNodeGuid] = self.json2xml.convertToString(admJson);

                    callback(null);
                });
            }
        });
    };

    GenerateDashboard.prototype.processTestbenchManifest = function (tbManifestJson, designSpaceName, configName, configNodeGuid) {
        var self = this,
            resultDirName,
            resultMetaresult,
            testBenchName = tbManifestJson.TestBench,
            testbenchJson = new DashboardTypes.testbenchJson(testBenchName),
            tbParam,
            tbMetric,
            i;


        // modify the testbench_manifest.json
        tbManifestJson.DesignName = designSpaceName + '_' + configName;
        tbManifestJson.DesignID = '{' + configNodeGuid + '}';

        // add to the results.metaresults.json object
        resultDirName = Math.random().toString(36).substring(8);
        resultDirName += Object.keys(self.dashboardObject.results.results).length;
        resultMetaresult =
            new DashboardTypes.resultMetaresult(configNodeGuid, tbManifestJson.TestBench, resultDirName);

        self.dashboardObject.results.results[resultDirName] = JSON.stringify(tbManifestJson, null, 4);
        self.dashboardObject.results.resultsMetaresultsJson.Results.push(resultMetaresult);

        // Generate a testbench description
        // Parameters
        for (i = 0; i < tbManifestJson.Parameters.length; i++) {
            tbParam = tbManifestJson.Parameters[i];
            testbenchJson.Parameters.push(
                new DashboardTypes.testbenchParameter(tbParam.Name, tbParam.Value, tbParam.Unit, i + 1));
        }
        // Metrics
        for (i = 0; i < tbManifestJson.Metrics.length; i++) {
            tbMetric = tbManifestJson.Metrics[i];
            testbenchJson.Metrics.push(
                new DashboardTypes.testbenchMetric(tbMetric.Name, tbMetric.Value, tbMetric.Unit, i + 1));
        }

        testBenchName += ".testbench.json";
        self.dashboardObject.testBenches[testBenchName] = JSON.stringify(testbenchJson, null, 4);
    };

    GenerateDashboard.prototype.getTestbenchManifest = function (tbManifestHash, callback) {
        var self = this,
            errMsg;

        self.blobClient.getObject(tbManifestHash, function (err, tbManifestContent) {
            if (err) {
                errMsg = "Could not get testbench_manifest from " + tbManifestHash + ": " + err;
                return callback(errMsg, null);
            }

            var tbManifestZip = new JSZip(tbManifestContent),
                tbManifestObject = tbManifestZip.file(/testbench_manifest.json/),  // regular expression will return an array
                tbManifestJson;

//            for (var fileName in tbManifestObject.files) {
//                if (tbManifestObject.files.hasOwnProperty(fileName)) {
//                    if (fileName.indexOf("testbench_manifest.json") > 0) {
//                        var splitName = fileName.split('/');
//                    }
//                }
//            }

            if (tbManifestObject === null) {
                errMsg = "Could not get testbench_manifest from " + tbManifestHash + ": " + err;
                self.logger.error(errMsg);
                return callback(errMsg, null);
            }

            // need to parse as json ???
            tbManifestJson = JSON.parse(tbManifestObject[0].asText());

            callback(null, tbManifestJson);
        });
    };

    GenerateDashboard.prototype.getCfgAdm = function (cfgAdmHash, callback) {
        var self = this,
            errMsg;

        self.blobClient.getObject(cfgAdmHash, function (err, cfgAdmObjectContent) {
            if (err) {
                errMsg = "Could not get adm from xml " + cfgAdmHash + ": " + err;
                return callback(errMsg, null);
            }

            var zip = new JSZip(cfgAdmObjectContent),
                cfgAdmXml = zip.file(/\.adm/),  // regular expression will return an array
                cfgAdmJson;

            if (cfgAdmXml === null) {
                errMsg = "Could not get adm from xml " + cfgAdmHash + ": " + err;
                self.logger.error(errMsg);
                return callback(errMsg, null);
            }

            // need to convert to json :(((
            cfgAdmJson = self.convertXml2Json(cfgAdmXml[0].asArrayBuffer());

            if (cfgAdmJson instanceof Error) {
                errMsg = 'Given adm not valid xml: ' + cfgAdmJson.message;
                return callback(errMsg, null);
            }

            callback(null, cfgAdmJson);
        });
    };

    GenerateDashboard.prototype.convertXml2Json = function (modelDescriptionXml) {
        var self = this,
            arrayElementsInXml = {
                Design: false,
                RootContainer: false,
                Value: false,
                Container: true,
                Connector: true,
                Property: true,
                Formula: true,
                Operand: true,
                ValueFlowMux: true,
                ComponentInstance: true,
                PrimitivePropertyInstance: true,
                ConnectorInstance: true,
                PortInstance: true,
                Role: true,
                Port: true
            },
            converter = new Converter.Xml2json({
                skipWSText: true,
                arrayElements: arrayElementsInXml
            });

        return converter.convertFromBuffer(modelDescriptionXml);
    };

    GenerateDashboard.prototype.initializeAdmExporter = function (designPath) {
        var self = this;
        if (self.admExporter === null) {
            self.admExporter = new AdmExporter();
            self.admExporter.meta = self.metaTypes;  // meta is defined here (points to adjacent meta.js file)
            self.admExporter.META = self.META;  // META is from PluginBase
            self.admExporter.core = self.core;
            self.admExporter.logger = self.logger;
            self.admExporter.result = self.result;
            self.admExporter.rootPath = designPath || null;
            self.admExporter.rootNode = self.rootNode;
            self.logger.info('AdmExporter had not been initialized - created a new instance.');
        } else {
            self.admExporter.acmFiles = {};
            self.admExporter.gatheredAcms = {};
            self.admExporter.rootPath = designPath || null;
            self.admExporter.includeAcms = true;
            self.logger.info('AdmExporter had already been initialized - reset acmFiles, gatheredAcms and rootPath.');
        }
    };

    return GenerateDashboard;
});