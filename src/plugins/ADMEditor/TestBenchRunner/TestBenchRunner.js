//noinspection JSLint
/**
* Generated by PluginGenerator from webgme on Thu May 22 2014 22:27:57 GMT-0500 (Central Daylight Time).
*/

define(['plugin/PluginConfig',
        'plugin/PluginBase',
        'plugin/TestBenchRunner/TestBenchRunner/meta',
        'plugin/TestBenchRunner/TestBenchRunner/Templates/Templates',
        'plugin/AdmExporter/AdmExporter/AdmExporter',
        'plugin/AdmExporter/AtmExporter/AtmExporter',
        'xmljsonconverter',
        'executor/ExecutorClient',
        'ejs'
    ],function (PluginConfig, PluginBase, MetaTypes, TEMPLATES, AdmExporter, AtmExporter, Converter, ExecutorClient, ejs) {
    'use strict';
//<editor-fold desc="============================ Class Definition ================================">
    /**
    * Initializes a new instance of TestBenchRunner.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin TestBenchRunner.
    * @constructor
    */
    var TestBenchRunner = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.meta = MetaTypes;
        this.referencedDesign = null;
        this.saveToModel = false;
        // Execution frame-work.
        this.runExecution = false;
        this.run_exec_cmd = null;
        this.exec_py = null;
        this.executorClient = null;
        this.dashboardResults = [];
        this.projectManifest = null;
        this.metaResults = null;
        this.designNameToDesignId = {};
        // AVM design format
        this.designAcmFiles = null;
        this.admData = null;
        this.admString = null;
        this.exportAtm = false;
        this.atms = [];

        this.admExporter = null;
        this.atmExporter = null;
    };

    // Prototypal inheritance from PluginBase.
    TestBenchRunner.prototype = Object.create(PluginBase.prototype);
    TestBenchRunner.prototype.constructor = TestBenchRunner;

    /**
    * Gets the name of the TestBenchRunner.
    * @returns {string} The name of the plugin.
    * @public
    */
    TestBenchRunner.prototype.getName = function () {
        return "Test bench runner";
    };

    /**
    * Gets the semantic version (semver.org) of the TestBenchRunner.
    * @returns {string} The version of the plugin.
    * @public
    */
    TestBenchRunner.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Gets the description of the TestBenchRunner.
    * @returns {string} The description of the plugin.
    * @public
    */
    TestBenchRunner.prototype.getDescription = function () {
        return "Exports the design and run the test-bench from where it is called.";
    };

    /**
    * Gets the configuration structure for the TestBenchRunner.
    * The ConfigurationStructure defines the configuration for the plugin
    * and will be used to populate the GUI when invoking the plugin from webGME.
    * @returns {object} The version of the plugin.
    * @public
    */
    TestBenchRunner.prototype.getConfigStructure = function () {
        return [
            {
                'name': 'run',
                'displayName': 'Run test-bench',
                'description': 'Will start a job and run the test-bench.',
                'value': false,
                'valueType': 'boolean',
                'readOnly': false
            },
            {
                'name': 'save',
                'displayName': 'Save results',
                'description': 'Will save the results back to the model (only applicable when run is selected).',
                'value': false,
                'valueType': 'boolean',
                'readOnly': false
            },
            {
                'name': 'configurationPath',
                'displayName': 'DesertConfigurationID',
                'description': 'ID of DesertConfiguration object inside referenced TopLevelSystemUnderTest.',
                'value': '',
                'valueType': 'string',
                'readOnly': false
            }
        ];
    };
//</editor-fold>

    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always has to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    TestBenchRunner.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            currentConfig = self.getCurrentConfig();

        if (!self.activeNode) {
            self.createMessage(null, 'Active node is not present! This happens sometimes... Loading another model ' +
                'and trying again will solve it most of times.', 'error');
            callback('Active node is not present!', self.result);
            return;
        }
        if (self.isMetaTypeOf(self.activeNode, self.META.AVMTestBenchModel) === false) {
            self.createMessage(null, 'This plugin must be called from an AVMTestBenchModel.', 'error');
            callback(null, self.result);
            return;
        }
        self.updateMETA(self.meta);
        self.runExecution = currentConfig.run;
        self.saveToModel = currentConfig.save;
        self.cfgPath = currentConfig.configurationPath;

        self.getTestBenchInfo(self.activeNode, function (err, testBenchInfo) {
            if (err) {
                self.logger.error('getTestBenchInfo returned with error: ' + err.toString());
                self.createMessage(self.activeNode, 'Something went wrong when exploring the test-bench.', 'error');
                callback(null, self.result);
                return;
            }
            self.getAdmAndAcms(self.referencedDesign, [testBenchInfo], function (err) {
                if (err) {
                    self.logger.error(err);
                    self.createMessage(self.referencedDesign, 'Something went wrong when exploring the referenced design.', 'error');
                    callback(null, self.result);
                    return;
                }
                self.generateExecutionFiles(testBenchInfo, function (err, artifact) {
                    if (err) {
                        callback('Could generateExecutionFiles : err' + err.toString(), self.result);
                        return;
                    }
                    artifact.save(function (err, hash) {
                        if (err) {
                            callback('Could not save artifact : err' + err.toString(), self.result);
                            return;
                        }
                        self.result.addArtifact(hash);
                        if (self.runExecution) {
                            self.executeJob(hash, testBenchInfo, function (err, success) {
                                if (err) {
                                    self.logger.error(err);
                                    callback(err, self.result);
                                }
                                self.result.setSuccess(success);
                                if (self.saveToModel) {
                                    self.save('Test-bench "' + testBenchInfo.name + '" results was updated after execution.', function (err) {
                                        callback(null, self.result);
                                    });
                                } else {
                                    callback(null, self.result);
                                }
                            });
                        } else {
                            self.result.setSuccess(true);
                            callback(null, self.result);
                        }
                    });
                });
            });
        });
    };

    TestBenchRunner.prototype.getTestBenchInfo = function (testBenchNode, callback) {
        var self = this,
            testBenchInfo = {};
        testBenchInfo.name = self.core.getAttribute(testBenchNode, 'name');
        testBenchInfo.path = self.core.getAttribute(testBenchNode, 'ID');
        testBenchInfo.testBenchFilesHash = self.core.getAttribute(testBenchNode, 'TestBenchFiles');
        testBenchInfo.node = testBenchNode;
        if (!testBenchInfo.path) {
            self.createMessage(testBenchNode, 'There is no "ID" provided for the test-bench. It must be a path' +
                ' in the project-tree of the xme in asset "TestBenchFiles", e.g. /TestBenches/Dynamics/MyTestBench', 'error');
            callback('TestBench ID not provided.');
            return;
        }
        self.logger.info('Getting data for test-bench "' + testBenchInfo.name + '".');
        self.initializeAtmExporter();
        self.atmExporter.getTlsutInterface(testBenchNode, function (err, tlsut) {
            if (err) {
                self.createMessage(testBenchNode, 'Could not obtain Top Level System Under test interface.', 'error');
                callback('Something went wrong when getting tlsut interface err: ' + err);
                return;
            }
            testBenchInfo.tlsut = tlsut;

            // For single test-benches check the reference for the test-bench and its parent folder.
            if (self.core.hasPointer(testBenchNode, 'TopLevelSystemUnderTest')) {
                self.logger.info('Test-bench has TopLevelSystemUnderTest ref set.');
                self.core.loadPointer(testBenchNode, 'TopLevelSystemUnderTest', function (err, design) {
                    if (err) {
                        self.logger.error('loading TLSUT failed with err: ' + err.toString());
                        callback(err);
                        return;
                    }
                    self.referencedDesign = design;
                    callback(null, testBenchInfo);
                });
            } else {
                self.createMessage(testBenchNode, 'No TopLevelSystemUnderTest reference set for test-bench.', 'error');
                callback('Found no reference to TLSUT.');
            }
        });
    };

    TestBenchRunner.prototype.getAdmAndAcms = function (designNode, testBenchInfos, callback) {
        var self = this;
        self.checkDesignAgainstTLSUTs(designNode, testBenchInfos, function (err, result) {
            if (err) {
                callback(err);
                return;
            }
            if (result !== true) {
                self.createMessage(designNode, 'Design did not match TopLevelSystemUnderTests!', 'error');
                callback('Design did not match TopLevelSystemUnderTests!');
                return;
            }
            self.initializeAdmExporter();
            self.admExporter.setupDesertCfg(self.cfgPath, function (err) {
                if (err) {
                    callback('Failed setting up desertConfigurations, err: ' + err);
                    return;
                }
                if (self.admExporter.selectedAlternatives) {
                    self.logger.info('Running on single configuration');
                    self.logger.info(JSON.stringify(self.admExporter.selectedAlternatives, null));
                }
                self.admExporter.exploreDesign(designNode, true, function (err) {
                    if (err) {
                        callback('AdmExporter.exploreDesign failed with error: ' + err);
                        return;
                    }
                    self.admData = self.admExporter.admData;
                    self.designAcmFiles = self.admExporter.acmFiles;
                    callback(null);
                });
            });
        });
    };

    TestBenchRunner.prototype.checkDesignAgainstTLSUTs = function (designNode, testBenchInfos, callback) {
        var self = this,
            k,
            key,
            mergedProperties = {},
            mergedConnectors = {};
        for (k = 0; k < testBenchInfos.length; k += 1) {
            for (key in testBenchInfos[k].tlsut.properties) {
                if (testBenchInfos[k].tlsut.properties.hasOwnProperty(key)) {
                    mergedProperties[key] = testBenchInfos[k].tlsut.properties[key];
                }
            }
            for (key in testBenchInfos[k].tlsut.connectors) {
                if (testBenchInfos[k].tlsut.connectors.hasOwnProperty(key)) {
                    mergedConnectors[key] = testBenchInfos[k].tlsut.connectors[key];
                }
            }
        }

        self.core.loadChildren(designNode, function (err, children) {
            var counter, i,
                error = '',
                metaTypeName,
                childName,
                counterCallback;
            if (err) {
                callback('loadChildren failed for tlsut with err:' + err.toString());
                return;
            }
            counter = children.length;
            counterCallback = function (err) {
                var innerKey,
                    isValid;

                error = err ? error + err : error;
                counter -= 1;
                if (counter <= 0) {
                    isValid = true;
                    for (innerKey in mergedProperties) {
                        if (mergedProperties.hasOwnProperty(innerKey) && mergedProperties[innerKey] !== true) {
                            //isValid = false;
                            self.createMessage(mergedProperties[innerKey], 'Design does not have property "' + innerKey
                                + '". Property checks are currently ignored.', 'warning');
                        }
                    }
                    for (innerKey in mergedConnectors) {
                        if (mergedConnectors.hasOwnProperty(innerKey) && mergedConnectors[innerKey] !== true) {
                            isValid = false;
                            self.createMessage(mergedConnectors[innerKey], 'Design does not have connector "' +
                                innerKey + '".', 'error');
                        }
                    }
                    callback(error, isValid);
                }
            };

            if (children.length === 0) {
                counterCallback(null);
            }

            for (i = 0; i < children.length; i += 1) {
                metaTypeName = self.core.getAttribute(self.getMetaType(children[i]), 'name');
                childName = self.core.getAttribute(children[i], 'name');
                if (metaTypeName === 'Property') {
                    if (mergedProperties[childName] !== undefined) {
                        mergedProperties[childName] = true;
                    }
                    counterCallback(null);
                } else if (metaTypeName === 'Connector') {
                    if (mergedConnectors[childName] !== undefined) {
                        mergedConnectors[childName] = true;
                    }
                    counterCallback(null);
                } else {
                    counterCallback(null);
                }
            }
        });
    };

    TestBenchRunner.prototype.initializeAdmExporter = function () {
        var self = this;
        if (self.admExporter === null) {
            self.admExporter = new AdmExporter();
            self.admExporter.meta = self.meta;
            self.admExporter.META = self.META;
            self.admExporter.core = self.core;
            self.admExporter.logger = self.logger;
            self.admExporter.result = self.result;
            self.admExporter.rootNode = self.rootNode;
            self.logger.info('AdmExporter had not been initialized - created a new instance.');
        } else {
            self.admExporter.acmFiles = {};
            self.admExporter.gatheredAcms = {};
            self.admExporter.rootPath = null;
            self.admExporter.includeAcms = true;
            self.logger.info('AdmExporter had already been initialized - reset acmFiles, gatheredAcms and rootPath.');
        }
    };

    TestBenchRunner.prototype.initializeAtmExporter = function () {
        var self = this;
        self.atmExporter = new AtmExporter();
        self.atmExporter.meta = self.meta;
        self.atmExporter.META = self.META;
        self.atmExporter.core = self.core;
        self.atmExporter.logger = self.logger;
        self.atmExporter.result = self.result;
        self.atmExporter.atmData = null;
        self.logger.info('AtmExporter initialized.');
    };

    TestBenchRunner.prototype.generateExecutionFiles = function (testBenchInfo, callback) {
        var self = this,
            artifact,
            executorConfig,
            jsonToXml,
            testbenchConfig,
            filesToAdd = {};
        self.logger.info('Generating execution files.');
        if (!self.admString) {
            // Only convert the common ejs files once.
            self.logger.info('This was first generation of common filesToAdd.');
            jsonToXml = new Converter.Json2xml();
            self.admString = jsonToXml.convertToString({Design: self.admData});
            self.run_exec_cmd = ejs.render(TEMPLATES['run_execution.cmd.ejs']);
            self.exec_py = ejs.render(TEMPLATES['execute.py.ejs']);
        }
        filesToAdd[self.admData['@Name'] + '.adm'] = self.admString;
        filesToAdd['run_execution.cmd'] = self.run_exec_cmd;
        filesToAdd['execute.py'] = self.exec_py;
        executorConfig = JSON.stringify({
            cmd: 'run_execution.cmd',
            resultArtifacts: [
                {
                    name: 'dashboard',
                    resultPatterns: ['dashboard/**', 'designs/**', 'design-space/**', 'requirements/**',
                        'test-benches/**', 'results/*/testbench_manifest.json', 'results/results.metaresults.json',
                        'manifest.project.json', 'index.html', '*.svg']
                },
                {
                    name: 'logs',
                    resultPatterns: [ 'log/**', '_FAILED.txt']
                },
                {
                    name: 'all',
                    resultPatterns: []
                },
                {
                    name: 'testBenchManifest',
                    resultPatterns: ['results/*/testbench_manifest.json']
                },
                {
                    name: 'cfgAdm',
                    resultPatterns: ['designs/**']
                }
            ]

        }, null, 4);
        filesToAdd['executor_config.json'] = executorConfig;
        testbenchConfig = JSON.stringify({ name: testBenchInfo.name, path: testBenchInfo.path }, null, 4);
        filesToAdd['testbench_config.json'] = testbenchConfig;
        self.logger.info('TestBenchConfig : ' + testbenchConfig);
        self.logger.info('ExecutorConfig  : ' + executorConfig);

        artifact = self.blobClient.createArtifact(testBenchInfo.name);
        artifact.addMetadataHash('tbAsset.zip', testBenchInfo.testBenchFilesHash, function (err, hash) {
            if (err) {
                callback('Could not add tbAsset.zip from test-bench : err' + err.toString());
                return;
            }
            artifact.addObjectHashes(self.designAcmFiles, function (err, hashes) {
                if (err) {
                    callback('Could not add acm files : err' + err.toString());
                    return;
                }
                artifact.addFiles(filesToAdd, function (err, hashes) {
                    if (err) {
                        callback('Could not add script files : err' + err.toString());
                        return;
                    }
                    callback(null, artifact);
                });
            });
        });
    };

    TestBenchRunner.prototype.executeJob = function (artifactHash, testBenchInfo, callback) {
        var self = this;

        if (!self.executorClient) {
            self.logger.info('First execution, creating executor client..');
            self.executorClient = new ExecutorClient();
        }
        self.executorClient.createJob(artifactHash, function (err, jobInfo) {
            var intervalID,
                atSucceedJob;
            if (err) {
                callback('Creating job failed for "' + testBenchInfo.name + '", err: '  + err.toString(), false);
                return;
            }
            self.logger.info('Initial job-info:' + JSON.stringify(jobInfo, null, 4));

            atSucceedJob = function (jInfo) {
                var key;
                self.logger.info('Execution for test-bench "' + testBenchInfo.name + '"  succeeded.');
                self.logger.info('Its final JobInfo looks like : ' + JSON.stringify(jInfo, null, 4));
                for (key in jInfo.resultHashes) {
                    if (jInfo.resultHashes.hasOwnProperty(key)) {
                        self.result.addArtifact(jInfo.resultHashes[key]);
                    }
                }
                self.blobClient.getMetadata(jInfo.resultHashes.logs, function (err, metadata) {
                    if (err) {
                        callback('Could not get metadata for result. Err: ' + err, false);
                        return;
                    }
                    if (metadata.content.hasOwnProperty('_FAILED.txt')) {
                        self.createMessage(testBenchInfo.node, 'Execution had errors - download execution_results for "' +
                            testBenchInfo.name + '" and read _FAILED.txt', 'error');
                        callback(null, false);
                        return;
                    }
                    self.core.setAttribute(testBenchInfo.node, 'Results', jInfo.resultHashes.dashboard);
                    if (self.cfgPath) {
                        self.core.loadByPath(self.rootNode, self.cfgPath, function (err, cfgNode) {
                            var resultNode;
                            resultNode = self.core.createNode({parent: cfgNode, base: self.meta.Result});
                            self.core.setAttribute(resultNode, 'CfgAdm', jInfo.resultHashes.cfgAdm);
                            self.core.setPointer(resultNode, 'ExecutedTestBench', testBenchInfo.node);
                            self.core.setAttribute(resultNode, 'TestBenchManifest', 'It ran successfully..');
                            self.core.setAttribute(resultNode, 'Artifacts', jInfo.resultHashes.testBenchManifest);
                            self.logger.info('Execution succeeded for test-bench "' + testBenchInfo.name + '".');
                            callback(null, true);
                        });
                    } else {
                        self.logger.info('Execution succeeded for test-bench "' + testBenchInfo.name + '".');
                        callback(null, true);
                    }
                });
            };

            //noinspection JSLint
            intervalID = setInterval(function () {
                // Get the job-info at intervals and check for a non-CREATED status.
                self.executorClient.getInfo(artifactHash, function (err, jInfo) {
                    self.logger.info(JSON.stringify(jInfo, null, 4));
                    if (jInfo.status === 'CREATED' || jInfo.status === 'RUNNING') {
                        // The job is still running..
                        return;
                    }
                    //noinspection JSLint
                    clearInterval(intervalID);
                    if (jInfo.status === 'SUCCESS') {
                        atSucceedJob(jInfo);
                    } else {
                        self.result.addArtifact(jInfo.resultHashes[testBenchInfo.name + '_logs']);
                        self.result.addArtifact(jInfo.resultHashes[testBenchInfo.name + '_all']);
                        callback('Job execution failed', false);
                    }
                });
            }, 2000);
        });
    };

//<editor-fold desc="============================ Unused methods ===============================">

    TestBenchRunner.prototype.mergeDashBoards = function (callback) {
        var self = this,
            masterDashHash,

            mergedArtifact;
        if (!(self.multiRun && self.runExecution && self.dashboardResults.length > 0)) {
            self.logger.info('No dashboards to merge.');
            callback(null);
            return;
        }

        mergedArtifact = self.blobClient.createArtifact('mergedDashboards');
        masterDashHash = self.dashboardResults[0];
        self.dashboardResults.shift();
        self.blobClient.getMetadata(masterDashHash, function (err, metaData) {
            if (err) {
                callback('Could not get metadata for masterDashHash. Err: ' + err);
                return;
            }
            self.getProjectManifestAndMetaResults(metaData, function (err, projectManifest, metaResults) {
                var exclude = {};
                if (err) {
                    callback(err);
                    return;
                }
                self.projectManifest = projectManifest;
                self.metaResults = metaResults;
                exclude['manifest.project.json'] = true;
                exclude['results/results.metaresults.json'] = true;
                self.addMetaDatasToArtifact(metaData.content, mergedArtifact, exclude, function (err, tbManifests) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    self.getDesignCfgToDesignId(tbManifests, function (err, cfgToDesignId) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        self.logger.info(JSON.stringify(cfgToDesignId, null, 2));
                        self.designNameToDesignId = cfgToDesignId;
                        self.addSlavesDashFiles(mergedArtifact, function (err) {
                            var filesToAdd;
                            if (err) {
                                callback(err);
                                return;
                            }
                            filesToAdd = {
                                'manifest.project.json': JSON.stringify(self.projectManifest, null, 4),
                                'results/results.metaresults.json': JSON.stringify(self.metaResults, null, 4)
                            };
                            mergedArtifact.addFiles(filesToAdd, function (err, hashes) {
                                if (err) {
                                    callback(err);
                                    return;
                                }
                                mergedArtifact.save(function (err, artieHash) {
                                    if (err) {
                                        callback(err);
                                        return;
                                    }
                                    self.result.addArtifact(artieHash);
                                    self.core.setAttribute(self.activeNode, 'Results', artieHash);
                                    callback(null);
                                });
                            });
                        });
                    });
                });
            });
        });
    };

    TestBenchRunner.prototype.getJSObjFromMetaData = function (metaData, callback) {
        var self = this,
            contentHash = metaData.content;
        self.logger.info('About to get JS-object from meta-data: ' +
            JSON.stringify(metaData, null, 2) + '.');
        self.blobClient.getObject(contentHash, function (err, content) {
            var jsonString;
            if (err) {
                callback('Could not get content, err :' + err.toString());
                return
            }
            jsonString = String.fromCharCode.apply(null, new Uint8Array(content));
            self.logger.info(jsonString);
            callback(null, JSON.parse(jsonString));
        });
    };

    TestBenchRunner.prototype.getProjectManifestAndMetaResults = function (metaData, callback) {
        var self = this,
            manifestName = 'manifest.project.json',
            metaResName = 'results/results.metaresults.json';

        self.getJSObjFromMetaData(metaData.content[manifestName], function (err, projectManifest) {
            if (err) {
                callback(err);
                return
            }
            self.getJSObjFromMetaData(metaData.content[metaResName], function (err, metaResults) {
                if (err) {
                    callback(err);
                    return
                }
                callback(null, projectManifest, metaResults);
            });
        });
    };

    TestBenchRunner.prototype.addMetaDatasToArtifact = function (metaDatas, artifact, exclude, callback) {
        var self = this,
            metaDataToAdd = {},
            toExclude = exclude || {},
            fileName,
            testBenchManifests = [];
        for (fileName in metaDatas) {
            if (metaDatas.hasOwnProperty(fileName) && toExclude[fileName] === undefined) {
                metaDataToAdd[fileName] = metaDatas[fileName].content;
                if (self.endsWith(fileName, '/testbench_manifest.json')) {
                    testBenchManifests.push({
                        fileName: fileName,
                        softLinkHash: metaDatas[fileName]
                    });
                }
            }
        }

        artifact.addMetadataHashes(metaDataToAdd, function (err, hashes) {
            if (err) {
                callback('Could not add metaDatas to artifact, err:' + err);
                return;
            }
            callback(null, testBenchManifests);
        });
    };

    TestBenchRunner.prototype.getDesignCfgToDesignId = function (testBenchManifests, callback) {
        var self = this,
            counter = testBenchManifests.length,
            error = '',
            i,
            cfgToDesignId = {},
            counterCallback = function (err, tbManifestObj) {
                error = err ? error + err : error;
                if (tbManifestObj) {
                    cfgToDesignId[tbManifestObj.DesignName] = tbManifestObj.DesignID;
                }
                counter -= 1;
                if (counter <= 0) {
                    callback(error, cfgToDesignId);
                }
            };
        if (testBenchManifests.length === 0) {
            counterCallback('No test-bench manifest in master dashboard result!', null);
        }
        for (i = 0; i < testBenchManifests.length; i += 1) {
            self.getJSObjFromMetaData(testBenchManifests[i].softLinkHash, counterCallback);
        }
    };

    TestBenchRunner.prototype.addSlavesDashFiles = function (artifact, callback) {
        var self = this,
            counter = self.dashboardResults.length,
            error = '',
            i,
            counterCallback = function (err) {
                error = err ? error + err : error;
                counter -= 1;
                if (counter <= 0) {
                    callback(error);
                }
            };

        if (self.dashboardResults.length === 0) {
            counterCallback(null);
        }
        for (i = 0; i < self.dashboardResults.length; i += 1) {
            self.addSlaveDashFiles(self.dashboardResults[i], artifact, counterCallback);
        }
    };

    TestBenchRunner.prototype.addSlaveDashFiles = function (dashHash, artifact, callback) {
        var self = this;
        self.blobClient.getMetadata(dashHash, function (err, slaveDashMetaData) {
            if (err) {
                callback('Could not get metadata for masterDashHash. Err: ' + err);
                return;
            }
            self.getProjectManifestAndMetaResults(slaveDashMetaData, function (err, projectManifest, metaResults) {
                var testBenchPath,
                    i,
                    metaDataToAdd = {},
                    filesToAdd = {},
                    counterCallback,
                    error = '',
                    counter;
                if (err) {
                    callback(err);
                    return;
                }
                // Add info from project-manifest
                testBenchPath = projectManifest.Project.TestBenches[0];
                self.projectManifest.Project.TestBenches.push(testBenchPath);
                testBenchPath = testBenchPath.substring(2);
                metaDataToAdd[testBenchPath] = slaveDashMetaData.content[testBenchPath].content;
                // Add info from meta-results.
                counter = metaResults.Results.length;
                counterCallback = function (err) {
                    error = err ? error + err : error;
                    counter -= 1;
                    if (counter <= 0) {
                        artifact.addMetadataHashes(metaDataToAdd, function (err, hashes) {
                            if (err) {
                                callback('Could not add metaDatas of slave to artifact, err:' + err);
                                return;
                            }
                            artifact.addFiles(filesToAdd, function (err, hashes) {
                                if (err) {
                                    callback('Could not add files of slave to artifact, err:' + err);
                                    return;
                                }
                                callback(null);
                            });
                        });
                    }
                };
                if (metaResults.Results.length === 0) {
                    counterCallback('No results for: ' + JSON.stringify(projectManifest, null, 2));
                }
                for (i = 0; i < metaResults.Results.length; i += 1) {
                    self.mergeResult(slaveDashMetaData, metaResults.Results[i], filesToAdd, counterCallback);
                }
            });
        });
    };

    TestBenchRunner.prototype.mergeResult = function (metaData, result, filesToAdd, callback) {
        var self = this,
            tbManifestPath;
        tbManifestPath = 'results' + result.Summary.substring(1);
        self.logger.info(JSON.stringify(metaData.content, null, 2));
        self.logger.info(tbManifestPath);
        self.getJSObjFromMetaData(metaData.content[tbManifestPath], function (err, tbManifest) {
            var designName;
            if (err) {
                callback('Could not get test-bench object, err: ' + err);
                return;
            }
            designName = tbManifest.DesignName;
            if (self.designNameToDesignId.hasOwnProperty(designName)) {
                tbManifest.DesignID = self.designNameToDesignId[designName];
                filesToAdd[tbManifestPath] = JSON.stringify(tbManifest, null, 4);
                result.DesignID = tbManifest.DesignID;
                self.metaResults.Results.push(result);
            } else {
                self.createMessage(self.activeNode, 'Design names are not equal amongst test-benches. "' + designName +
                    '" did not exist in all dashboard folders.', 'warning');
            }
            callback(null);
        });
    };
//</editor-fold>

    TestBenchRunner.prototype.endsWith = function (str, ending) {
        var lastIndex = str.lastIndexOf(ending);
        return (lastIndex !== -1) && (lastIndex + ending.length === str.length);
    };

    TestBenchRunner.prototype.save2 = function (message, callback) {
        var self = this;

        this.logger.debug('Saving project');

        // Commit changes.
        this.core.persist(this.rootNode, function (err) {
            // TODO: any error here?
            if (err) {
                self.logger.error(err);
            }
        });

        var newRootHash = this.core.getHash(this.rootNode);

        var commitMessage = '[Plugin] ' + this.getName() + ' (v' + this.getVersion() + ') updated the model.';
        if (message) {
            commitMessage += ' - ' + message;
        }

        this.currentHash = this.project.makeCommit([this.currentHash], newRootHash, commitMessage, function (err) {
            // TODO: any error handling here?
            if (err) {
                self.logger.error(err);
            }
        });

        if (this.branchName) {
            // try to fast forward branch if there was a branch name defined

            // FIXME: what if master branch is already in a different state?

            this.project.getBranchNames(function (err, branchNames) {
                if (branchNames.hasOwnProperty(self.branchName)) {
                    var branchHash = branchNames[self.branchName];
                    if (branchHash === self.branchHash) {
                        // the branch does not have any new commits
                        // try to fast forward branch to the current commit
                        self.project.setBranchHash(self.branchName, self.branchHash, self.currentHash, function (err) {
                            if (err) {
                                // fast forward failed
                                self.logger.error(err);
                                self.logger.info('"' + self.branchName + '" was NOT updated');
                                self.logger.info('Project was saved to ' + self.currentHash + ' commit.');
                            } else {
                                // successful fast forward of branch to the new commit
                                self.logger.info('"' + self.branchName + '" was updated to the new commit.');
                                // roll starting point on success
                                self.branchHash = self.currentHash;
                            }
                            callback(err);
                        });
                    } else {
                        // branch has changes a merge is required
                        // TODO: try auto-merge, if fails ...
                        self.logger.warn('Cannot fast forward "' + self.branchName + '" branch. Merge is required but not supported yet.');
                        self.logger.info('Project was saved to ' + self.currentHash + ' commit.');
                        self.logger.info('Loading latest commit, from ' + self.branchHash);
                        self.project.getBranchHash(self.branchName, self.branchHash, function (err, arg1, arg2) {
                            if (err) {
                                self.logger.error(err);
                                return;
                            }
                            console.log('arg1', arg1);
                            console.log('arg1', arg2);
                            callback(null);
                        });
                    }
                } else {
                    // branch was deleted or not found, do nothing
                    self.logger.info('Project was saved to ' + self.currentHash + ' commit.');
                    callback(null);
                }
            });
            // FIXME: is this call async??
            // FIXME: we are not tracking all commits that we make

        } else {
            // making commits, we have not started from a branch
            this.logger.info('Project was saved to ' + this.currentHash + ' commit.');
            callback(null);
        }
    };

    return TestBenchRunner;
});