/* Generated file based on ejs templates */
define([], function() {
    return {
    "execute.py.ejs": "import os\r\nimport sys\r\nimport json\r\nimport shutil\r\nimport zipfile\r\nimport logging\r\nimport subprocess\r\nimport pywintypes\r\nimport win32com.client\r\n## Setup a logger\r\nlogger = logging.getLogger()\r\nlogger.setLevel(logging.DEBUG)\r\n\r\n# Create file handler which logs even debug messages.\r\nif not os.path.isdir('log'):\r\n    os.mkdir('log')\r\n\r\nfh = logging.FileHandler(os.path.join('log', 'execute.log'))\r\nfh.setLevel(logging.DEBUG)\r\n\r\n# Create console handler to stdout with logging level info.\r\nch = logging.StreamHandler(sys.stdout)\r\nch.setLevel(logging.INFO)\r\n\r\n# Create console handler to stderr with logging level error.\r\nch_err = logging.StreamHandler()\r\nch_err.setLevel(logging.ERROR)\r\n\r\n# Create formatter and add it to the handlers.\r\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\r\nfh.setFormatter(formatter)\r\nch.setFormatter(formatter)\r\nch_err.setFormatter(formatter)\r\n\r\n# Add the handlers to the logger.\r\nlogger.addHandler(fh)\r\nlogger.addHandler(ch)\r\nlogger.addHandler(ch_err)\r\n\r\ndef close_log():\r\n    fh.close()\r\nimport atexit\r\natexit.register(close_log)\r\n\r\n## Obtain the root directory for the META-tools.\r\n# Get the running meta-python path.\r\nsys_pieces = sys.executable.split(os.path.sep)\r\n# Drop the 'bin/Python27/Scripts/python.exe' part.\r\nif len(sys_pieces) < 4:\r\n    logger.error('Python script must be called using the META-python virtual env!')\r\n    sys.exit(1)\r\nsys_pieces = sys_pieces[:-4]\r\n# Make sure to get the slashes after e.g. \"C:\".\r\nif sys_pieces[0].endswith(':'):\r\n    sys_pieces[0] = sys_pieces[0] + os.path.sep\r\n# Join the pieces.\r\nMETA_DIR = os.path.join(*sys_pieces)\r\n\r\n# Disable early binding: full of race conditions writing the cache files,\r\n# and changes the semantics since inheritance isn't handled correctly\r\nimport win32com.client.gencache\r\n_savedGetClassForCLSID = win32com.client.gencache.GetClassForCLSID\r\nwin32com.client.gencache.GetClassForCLSID = lambda x: None\r\n\r\n\r\ndef call_subprocess_with_logging(command, my_env=None):\r\n    \"\"\"\r\n    Calls the command, if error occurred logging is made of all non-empty returns.\r\n    Reraises the exception putting the formatted message in returncode\r\n\r\n    :param command: the command to be executed\r\n    :param my_env: dictionary of environment-variables, None -> uses the default windows\r\n    \"\"\"\r\n    logger.info(\"About to call : {0}\".format(command))\r\n    return_code = 0\r\n    try:\r\n        if my_env:\r\n            return_out = subprocess.check_output(command, stderr=subprocess.STDOUT, env=my_env, shell=True)\r\n        else:\r\n            return_out = subprocess.check_output(command, stderr=subprocess.STDOUT, shell=True)\r\n        logger.info('console output : \\n{0}'.format(return_out))\r\n    except subprocess.CalledProcessError as err:\r\n        msg = \"Subprocess call failed!\"\r\n        msg += \"\\n  return-code   : {0}\".format(err.returncode)\r\n        return_code = err.returncode\r\n        if err.output:\r\n            msg += \"\\n  console output: \\n\\n{0}\".format(err.output)\r\n        if err.message:\r\n            msg += \"\\n  error message : {0}\".format(err.message)\r\n        logger.error(msg)\r\n\r\n    return return_code\r\n\r\n\r\n\r\ndef parse_xme_and_save_to_mga(file_name):\r\n    \"\"\"\r\n    Imports the xme project and saves it to a mga-file with the same name.\r\n    (Will overwrite any existing mga with same path.)\r\n\r\n    returns : mga_path : path to newly created mga\r\n    \"\"\"\r\n    mga_file = file_name[:-4] + '.mga'\r\n    mga_path = os.path.abspath(mga_file)\r\n    logger.debug(\"About to parse .xme, mga will be saved to \" + mga_path)\r\n    parser = win32com.client.Dispatch('Mga.MgaParser')\r\n    (paradigm, paradigm_v, paradigm_guid, basename, version) = parser.GetXMLInfo(file_name)\r\n    logger.debug('Xme info :')\r\n    logger.debug('  paradigm     : {0}'.format(paradigm))\r\n    logger.debug('  paradigm_v   : {0}'.format(paradigm_v))\r\n    import uuid\r\n    logger.debug('  paradigm_guid: {0}'.format(str(uuid.UUID(bytes_le=paradigm_guid))))\r\n    logger.debug('  basename     : {0}'.format(basename))\r\n    logger.debug('  version      : {0}'.format(version))\r\n    if paradigm != 'CyPhyML':\r\n        raise IOError(\"Given xme file must be using CyPhyML as paradigm, not {0}\".format(paradigm))\r\n\r\n    project = win32com.client.Dispatch('Mga.MgaProject')\r\n    project.Create('MGA={0}'.format(mga_path), paradigm)\r\n    try:\r\n        parser.ParseProject(project, file_name)\r\n        project.Save()\r\n        logging.debug(\"Mga saved to \" + mga_file)\r\n    finally:\r\n        project.Close(True)\r\n\r\n    return mga_path\r\n\r\n\r\ndef extract_components(src_path='ACMs', dst_path='components_extracted'):\r\n    if os.path.isdir(dst_path):\r\n        logging.debug('Found dir :{0} - removing and making new...'.format(dst_path))\r\n        shutil.rmtree(dst_path)\r\n        os.mkdir(dst_path)\r\n    files = os.listdir(src_path)\r\n    logging.debug('Components found in directory : {0}'.format(files))\r\n    for f_name in files:\r\n        if f_name.endswith('.zip'):\r\n            zippy = zipfile.ZipFile(os.path.join(src_path, f_name))\r\n            zippy.extractall('\\\\\\\\?\\\\' + os.path.join(os.getcwd(), dst_path, f_name.rstrip('.zip')))\r\n\r\n\r\ndef import_components(mga_path, dir_path='components_extracted'):\r\n    exec_name = 'CyPhyComponentImporterCL.exe'\r\n    exec_path = os.path.join(META_DIR, 'bin', exec_name)\r\n    if not os.path.isfile(exec_path):\r\n        logging.debug('Did not find {0} in bin directory.'.format(exec_name))\r\n        logging.debug('Assuming developer machine, looking in src directory...'.format(exec_name))\r\n        exec_path = os.path.join(META_DIR, 'src', 'CyPhyComponentImporterCL', 'bin', 'Release', exec_name)\r\n        if not os.path.isfile(exec_path):\r\n            raise IOError('Did not find {0}'.format(exec_path))\r\n\r\n    command = '\"{0}\" -r \"{1}\" \"{2}\"'.format(exec_path, dir_path, mga_path)\r\n    rc = call_subprocess_with_logging(command)\r\n\r\n    return rc\r\n\r\n\r\ndef import_design(mga_path, adm_file, testbench_config):\r\n    project_conn_str = 'MGA={0}'.format(mga_path)\r\n    project = win32com.client.Dispatch('Mga.MgaProject')\r\n    project.Open(project_conn_str)\r\n    design_ids = []\r\n    is_in_transaction = False\r\n    try:\r\n        design_importer = win32com.client.Dispatch('MGA.Interpreter.CyPhyDesignImporter')\r\n        design_importer.Initialize(project)\r\n        logger.debug('About to begin transaction..')\r\n        project.BeginTransactionInNewTerr()\r\n        logger.debug('Transaction began.')\r\n        is_in_transaction = True\r\n        ## Find the test-bench and find the design placeholder.\r\n        testbench_mga = project.ObjectByPath(testbench_config['path'])\r\n        if not testbench_mga:\r\n            raise RuntimeError('Given test-bench path \"' + testbench_config['path'] + '\" does not exist in project!')\r\n        try:\r\n            logger.debug('Path returned MgaObject of type: {0}'.format(testbench_mga.MetaBase.Name))\r\n            #if not testbench_mga.MetaBase.Name == 'TestBench':\r\n            #    raise NotImplementedError('Only CyPhy TestBench supported!')\r\n            testbench_id = testbench_mga.ID\r\n            logger.debug('Found test-bench \"{0}\".'.format(testbench_mga.Name))\r\n            logger.debug('Test-bench ID : {0}.'.format(testbench_id))\r\n            tlsut_mga = [o for o in testbench_mga.GetChildrenOfKind('TopLevelSystemUnderTest')][0]\r\n            logger.debug('TopLevelSystem under test {0} refers to :'.format(tlsut_mga.Name))\r\n            logger.debug(' \"{0}\" ({1})'.format(tlsut_mga.Referred.Name, tlsut_mga.Referred.MetaBase.Name))\r\n        except pywintypes.com_error as err:\r\n            logger.error(err.message)\r\n            raise RuntimeError('Given test-bench not found or setup correctly.')\r\n        ## Import the design.\r\n        logger.debug('Calling CyPhyDesignImporter.ImportDesign.')\r\n        design_mga = design_importer.ImportDesignToDesignSpace(project, adm_file)\r\n        design_id = design_mga.ID\r\n        logger.debug('Design imported:')\r\n        logger.debug(' Name : {0}'.format(design_mga.Name))\r\n        logger.debug(' Type : {0}'.format(design_mga.MetaBase.Name))\r\n        logger.debug(' ID : {0}'.format(design_id))\r\n        logger.debug(' Path : {0}'.format(design_mga.AbsPath))\r\n\r\n        if design_mga.MetaBase.Name == 'DesignContainer':\r\n            logger.info('Creating DesignSpaceHelper')\r\n            desert = win32com.client.Dispatch('MGA.Interpreter.DesignSpaceHelper')\r\n            desert.Initialize(project)\r\n            logger.info('Calling ApplyConstraintsAndGenerateCWCs')\r\n            # selectedObjs = win32com.client.Dispatch('Mga.MgaFCOs')\r\n            desert.ApplyConstraintsAndGenerateCWCs(project, design_mga, False)\r\n            configurations = design_mga.GetChildrenOfKind('Configurations')\r\n            if configurations.Count == 0:\r\n                logger.warning('No Configurations found')\r\n            for cc in configurations:\r\n                logger.info('Found Configurations \"{0}\" inside design.'.format(cc.Name))\r\n                cfg_mgas = cc.GetChildrenOfKind('CWC')\r\n                for cfg_mga in cfg_mgas:\r\n                    logger.info(cfg_mga.AbsPath)\r\n                    design_ids.append(cfg_mga.ID)\r\n        else:\r\n            design_ids.append(design_id)\r\n        ## Reference the design from the top-level-system-under-test.\r\n        logger.debug('Creating ReferenceSwitcher')\r\n        ref_switcher = win32com.client.Dispatch('MGA.Interpreter.ReferenceSwitcher')\r\n        logger.debug('Switching referred in test-bench to design.')\r\n        tlsut_mga.Name = design_mga.Name\r\n        ref_switcher.SwitchReference(design_mga, tlsut_mga)\r\n        logger.debug('Design was placed in test-bench.')\r\n        logger.debug('About to commit transaction..')\r\n        project.CommitTransaction()\r\n        logger.debug('Transaction committed.')\r\n        is_in_transaction = False\r\n    finally:\r\n        if is_in_transaction:\r\n            logger.debug('About to abort transaction..')\r\n            project.AbortTransaction()\r\n            logger.debug('Transaction aborted.')\r\n            project.Close(True)\r\n        else:\r\n            logger.debug('About to save project..')\r\n            project.Close(False)\r\n            logger.debug('Project saved.')\r\n\r\n    return testbench_id, design_ids\r\n\r\n\r\ndef call_master_interpreter(mga_path, test_bench_id, cfg_ids):\r\n    project_conn_str = 'MGA={0}'.format(mga_path)\r\n    project = win32com.client.Dispatch('Mga.MgaProject')\r\n    project.Open(project_conn_str)\r\n    nbr_of_failures = 0\r\n    nbr_of_cfgs = 0\r\n    try:\r\n        logger.debug('Creating CyPhyMasterInterpreterAPI')\r\n        mi = win32com.client.Dispatch('CyPhyMasterInterpreter.CyPhyMasterInterpreterAPI')\r\n        mi.Initialize(project)\r\n        logger.debug('Creating ConfigurationSelectionLight')\r\n        config_light = win32com.client.Dispatch('CyPhyMasterInterpreter.ConfigurationSelectionLight')\r\n        config_light.ContextId = test_bench_id\r\n        config_light.SetSelectedConfigurationIds(cfg_ids)\r\n        config_light.KeepTemporaryModels = False\r\n        config_light.PostToJobManager = False\r\n        mi_results = mi.RunInTransactionWithConfigLight(config_light)\r\n        mi.WriteSummary(mi_results)\r\n\r\n        for res in mi_results:\r\n            nbr_of_cfgs += 1\r\n            logger.info('MasterInterpreter result : {0}'.format(res.Message))\r\n            if not res.Success:\r\n                logger.error('MasterIntpreter failed : {0}, Exception : {1}'.format(res.Message, res.Exception))\r\n                nbr_of_failures += 1\r\n        if nbr_of_failures > 0:\r\n            with open('_FAILED.txt', 'ab+') as f_out:\r\n                f_out.write('MasterInterprter failed on ' + str(nbr_of_failures) + ' out of ' + str(nbr_of_cfgs) +\r\n                            ' configurations. See log/execution.log and log/MasterInerpter.xxxx.log for more info.')\r\n    finally:\r\n        project.Close(True)\r\n\r\n    if nbr_of_failures == nbr_of_cfgs:\r\n        logger.error('No succeeded configurations from MasterInterpreter, aborting script..')\r\n        sys.exit(1)\r\n\r\n\r\ndef run_execution_jobs():\r\n    jobs = []\r\n    for root, dirs, files in os.walk('results'):\r\n        for f in files:\r\n            if f == 'testbench_manifest.json':\r\n                with open(os.path.join(root, 'testbench_manifest.json'), 'r') as f_in:\r\n                    tb_dict = json.load(f_in)\r\n                    if len(tb_dict['Steps']) == 0:\r\n                        logger.warning('Skipping job for design ' + tb_dict['DesignID'] + ' in ' + root +\r\n                                       ', since there are no steps. MasterInterpreter probably failed on this design.')\r\n                    else:\r\n                        cmd = tb_dict['Steps'][0]['Invocation']\r\n                        logger.info('Found cmd {0}'.format(cmd))\r\n                        job = {'cmd': cmd, 'dir': root, 'designId': tb_dict['DesignID']}\r\n                        jobs.append(job)\r\n                        logger.info('Added job {0}'.format(job))\r\n                break\r\n    root_dir = os.getcwd()\r\n    if os.path.isdir('testbench_manifests'):\r\n        shutil.rmtree('testbench_manifests')\r\n    os.mkdir('testbench_manifests')\r\n    failed_jobs = 0\r\n    nbr_of_jobs = len(jobs)\r\n    for job in jobs:\r\n        os.chdir(job['dir'])\r\n        try:\r\n            rc = call_subprocess_with_logging(job['cmd'])\r\n            if rc != 0:\r\n                logger.error('call failed! {0} in {1}'.format(job['cmd'], job['dir']))\r\n                failed_jobs += 1\r\n            elif os.path.isfile('_FAILED.txt'):\r\n                logger.error('Job \"{0}\" created _FAILED.txt'.format(job['cmd']))\r\n                failed_jobs += 1\r\n                with open('_FAILED.txt', 'r') as f_in:\r\n                    logger.error('\\r\\n'.join(f_in.readlines()))\r\n        finally:\r\n            os.chdir(root_dir)\r\n    if failed_jobs > 0:\r\n        with open('_FAILED.txt', 'ab+') as f_out:\r\n            f_out.write(str(failed_jobs) + ' of ' + str(nbr_of_jobs) +' jobs failed! See log/execute.log.')\r\n\r\n\r\ndef move_dashboard_files(new_dir):\r\n\r\n    # Entire directories\r\n    dashboard_dir = 'dashboard'\r\n    designs_dir = 'designs'\r\n    design_space_dir = 'design-space'\r\n    requirements_dir = 'requirements'\r\n    test_benches_dir = 'test-benches'\r\n    results_dir = 'results'\r\n\r\n    # Single files\r\n    meta_results_file = os.path.join(results_dir, 'results.metaresults.json')\r\n    project_file = 'manifest.project.json'\r\n    index_html = 'index.html'\r\n\r\n    # Delete/Create new result directory.\r\n    if os.path.isdir(new_dir):\r\n        shutil.rmtree(new_dir)\r\n    os.mkdir(new_dir)\r\n    os.mkdir(os.path.join(new_dir, results_dir))\r\n    # Copy single files.\r\n    shutil.copy(meta_results_file, os.path.join(new_dir, meta_results_file))\r\n    shutil.copy(project_file, os.path.join(new_dir, project_file))\r\n    shutil.copy(index_html, os.path.join(new_dir, index_html))\r\n    # Copy entire directories.\r\n    shutil.copytree(dashboard_dir, os.path.join(new_dir, dashboard_dir))\r\n    shutil.copytree(designs_dir, os.path.join(new_dir, designs_dir))\r\n    shutil.copytree(design_space_dir, os.path.join(new_dir, design_space_dir))\r\n    shutil.copytree(requirements_dir, os.path.join(new_dir, requirements_dir))\r\n    shutil.copytree(test_benches_dir, os.path.join(new_dir, test_benches_dir))\r\n\r\n    for dir_path in (os.path.join(results_dir, dd) for dd in os.listdir(results_dir)):\r\n        if os.path.isdir(dir_path):\r\n            tm_path = os.path.join(dir_path, 'testbench_manifest.json')\r\n            if os.path.isfile(tm_path):\r\n                os.mkdir(os.path.join(new_dir, dir_path))\r\n                shutil.copy(tm_path, os.path.join(new_dir, tm_path))\r\n\r\n\r\nif __name__ == '__main__':\r\n    with zipfile.ZipFile('tbAsset.zip') as zippy:\r\n        zippy.extractall('.')\r\n    try:\r\n        adm_path = [f for f in os.listdir('.') if f.endswith('.adm')][0]\r\n    except IndexError:\r\n        logger.error('Could not find an adm at {0}'.format(os.getcwd()))\r\n        with open('_FAILED.txt', 'ab+') as f_out:\r\n            f_out.write('Execution failed! See log/execute.log.')\r\n        sys.exit(1)\r\n    try:\r\n        xme_path = [f for f in os.listdir('.') if f.endswith('.xme')][0]\r\n    except IndexError:\r\n        logger.error('Could not find an adm or xme file at {0}'.format(os.getcwd()))\r\n        with open('_FAILED.txt', 'ab+') as f_out:\r\n            f_out.write('Execution failed! See log/execute.log.')\r\n        sys.exit(1)\r\n    with open('testbench_config.json', 'r') as f_in:\r\n        test_bench_config = json.load(f_in)\r\n    extract_components()\r\n    logger.info('(1) Components extracted...')\r\n    mga_file = parse_xme_and_save_to_mga(xme_path)\r\n    logger.info('(2) Mga created...')\r\n    rc = import_components(mga_file)\r\n    if rc == 0:\r\n        logger.info('(3) Components imported...')\r\n    else:\r\n        logger.error('Components could not be imported!')\r\n        with open('_FAILED.txt', 'ab+') as f_out:\r\n            f_out.write('Execution failed! See log/execute.log.')\r\n        sys.exit(1)\r\n    try:\r\n        test_bench_id, cfg_ids = import_design(mga_file, adm_path, test_bench_config)\r\n    except Exception as err:\r\n        import traceback\r\n        the_trace = traceback.format_exc()\r\n        logger.error('Exception raised in \"import_design\": {0}'.format(the_trace))\r\n        error_msg = err.message\r\n        if hasattr(err, 'excepinfo'):\r\n            error_msg = '{0} : {1}'.format(error_msg, err.excepinfo)\r\n        with open('_FAILED.txt', 'ab+') as f_out:\r\n            f_out.write('Could not import design and place it correctly in test-bench. Exception message : ' +\r\n                        error_msg + ' See logs for more info.')\r\n            sys.exit(1)\r\n\r\n    logger.info('(4) Design imported and placed in test-bench.')\r\n    call_master_interpreter(mga_file, test_bench_id, cfg_ids)\r\n    logger.info('(5) MasterInterpreter finished.')\r\n    run_execution_jobs()\r\n    logger.info('(6) Job execution completed.')\r\n",
    "run_execution.cmd.ejs": ":: Executes the package\r\necho off\r\npushd %~dp0\r\n%SystemRoot%\\SysWoW64\\REG.exe query \"HKLM\\software\\META\" /v \"META_PATH\"\r\n\r\nSET QUERY_ERRORLEVEL=%ERRORLEVEL%\r\n\r\nIF %QUERY_ERRORLEVEL% == 0 (\r\n        FOR /F \"skip=2 tokens=2,*\" %%A IN ('%SystemRoot%\\SysWoW64\\REG.exe query \"HKLM\\software\\META\" /v \"META_PATH\"') DO SET META_PATH=%%B)\r\nSET META_PYTHON_EXE=\"%META_PATH%\\bin\\Python27\\Scripts\\Python.exe\"\r\n    %META_PYTHON_EXE% execute.py %1\r\n)\r\nIF %QUERY_ERRORLEVEL% == 1 (\r\n    echo on\r\necho \"META tools not installed.\" >> _FAILED.txt\r\necho \"See Error Log: _FAILED.txt\"\r\npopd\r\nexit /b %QUERY_ERRORLEVEL%\r\n)\r\npopd\r\nexit /b %ERRORLEVEL%\r\n"
}});